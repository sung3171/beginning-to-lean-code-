i found it when i was searching backtracking. it help me to understand what is backtracking
planning to look over more

https://www.geeksforgeeks.org/rat-in-a-maze/


# Initialize a string direction which represents all the directions.
direction = "RULD" 

# Arrays to represent change in rows and columns
dr = [0, -1, 0, 1]
dc = [1, 0, -1, 0]

# Function to check if cell(row, col) is inside the maze
# and unblocked


def is_valid(row, col, n, maze):
    return 0 <= row < n and 0 <= col < n and maze[row][col] == 1

# Function to get all valid paths


def find_path(row, col, maze, n, ans, current_path):
    # If we reach the bottom right cell of the matrix, add
    # the current path to ans and return
    if row == n - 1 and col == n - 1:
        ans.append(current_path)
        return
    # Mark the current cell as blocked
    maze[row][col] = 0

    for i in range(4):
        # Find the next row based on the current row (row)
        # and the dr[] array
        next_row = row + dr[i]
        # Find the next column based on the current column
        # (col) and the dc[] array
        next_col = col + dc[i]

        # Check if the next cell is valid or not
        if is_valid(next_row, next_col, n, maze):
            current_path += direction[i]
            # Recursively call the find_path function for
            # the next cell
            find_path(next_row, next_col, maze, n, ans, current_path)
            # Remove the last direction when backtracking
            current_path = current_path[:-1]

    # Mark the current cell as unblocked
    maze[row][col] = 1


# Driver code
maze = [
    [1, 0, 0, 0],
    [1, 1, 0, 1],
    [1, 1, 0, 0],
    [0, 1, 1, 1]
]

n = len(maze)
# List to store all the valid paths
result = []
# Store current path
current_path = ""

if maze[0][0] != 0 and maze[n - 1][n - 1] != 0:
    # Function call to get all valid paths
    find_path(0, 0, maze, n, result, current_path)

if not result:
    print(-1)
else:
    print(" ".join(result))

now let's started how it works!
The main point I learned is that there are four directions;up down left right. to know well, on my opinion, let's think about it as counterclockwise.
maze = [
    [1, 0, 0, 0],
    [1, 1, 0, 1],
    [1, 1, 0, 0],
    [0, 1, 1, 1]
] (1 is path, 0 is wall)
first, we started at (0,0) point and we check where we are going to the next. we iterate total forth because we check it right up left down like as counterclockwise direction. 
the first iterate i=0's next direction is right but! it's wall and next up is out of range left is same out of range. so we can go to down as next point. and we (0,0) path remain 1(path) to 0(wall).(we consume all i(i=0,1,2,3))
 and next. we are on the (0,1) point. and we are going to move same as a moment ago right up left down. 
  first to move to right, due to 1 is a path, we can go immediatly to right. left before spot 1 to 0 and before we go in to recursion we consume i=0(right). (later we return,backtracking we consume all left i=1,2,3 up,left,down.)
 we can move with this method upto aim point (4,4) and we come out from recursion and we consume left i to find another way until we are going to reach starting point.(when come out from recursion, spot convert 0(wall) to 1(path)) 
 we can find two ways "DRDDRR"	"DDRDRR"
 D->DR->DRD->DRDD->...->DRDDRR  and let's come out from recursive. DRDDRR->DRDDR->DRDD->DRDL->DRD->DR->D->DD->DDR->DDRD->DDRDR->DDRDRR
and come out from recursive one more. while we are on recursive, we consume almost i and left 1 for another way we can reach without exception.
 that's all these code are constructed!

Now, let's start by understanding how it works! 
The main point I learned is that there are four directions: up, down, left, and right. 
To understand this well, in my opinion, we should think about it as counterclockwise. 
First, we start at the (0,0) point and check where we are going next. 
We iterate a total of four times, checking in the counterclockwise direction: right, up, left, and down.
First, to move to the right, since 1 is a path, we can move immediately to the right. 
Before moving left spot 1 to 0, and before we enter recursion, we already consume i=0 (right). 
(Later, when we backtrack(come out of recursion), we will consume all remaining directions: i=1 (up), i=2 (left), and i=3 (down).)
 We can use this method to move up to the target point (4,4). 
After coming out of recursion, we will consume the left direction i to find another path until we return to the starting point. 
When we exit recursion, the spot is converted from 0 (wall) to 1 (path). 
Finally, we find two paths: 'DRDDRR' and 'DDRDRR', and the maze remains as it originally was.
maze = [
    [1, 0, 0, 0],
    [1, 1, 0, 1],
    [1, 1, 0, 0],
    [0, 1, 1, 1]
] 
Start with D -> DR -> DRD -> DRDD -> ... -> DRDDRR and then exit the recursion. 
From DRDDRR, we backtrack to DRDDR -> DRDD -> DRDL -> DRD -> DR -> D -> DD -> DDR -> DDRD -> DDRDR -> DDRDRR. 
After coming out of recursion one more time, we have consumed almost all directions i, leaving 1 for another possible path, which allows us to reach the goal without exceptions. 

This is how and why the code is constructed and was created!



