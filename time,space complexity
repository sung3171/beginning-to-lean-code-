The start time is around 15:24 on September 2, 2024. The end time is about 18:26 on september 2, 2024
The start time is 22:03 on september 2, 2024
I document my undertand of caculating time complexity and space complexity.

class Solution:
    def isPalindrome(self,x:int)->bool:
        if x<0:
            return False
        temp=x
        reverse=0
        while temp>0:
            reverse=reverse*10+temp%10
            temp//=10
        return reverse==x
Although x is an integer, it doesn't mean the loop runs x times. 
As seen in the code, x is divided by 10 in each iteration of the while loop. 
The loop continues until x is no longer divisible by 10. For example, if x = 12321, then x will be divided by 10 repeatedly, 
and the loop will run approximately log(x) times. In this case, x // 10 reduces x each time, so the loop iterates about 5 times (log(12321) ≈ 5).
The space complexity is O(1) because only a constant amount of space is used. 
Variables like x, temp, and reverse occupy a fixed amount of memory, and their values are updated, but the amount of space used does not depend on the input size.

class Solution:
    def isPalindrome(self, x):
        if x < 0 or (x != 0 and x % 10 == 0):
            return False
        reverse = 0
        while x > reverse:
            reverse = reverse * 10 + x % 10
            x //= 10
        return reverse == x or x == reverse // 10

def example_algorithm(arr):
    total = 0
    for i in range(len(arr)):
        for j in range(len(arr)):
            total += arr[i] * arr[j]
    return total
Note:x=len(arr), The time complexity of this solution is O(x^2) because the nested for loops run a total of x^2 iterations. 
For example, if arr = [1, 2, 3] and x = len(arr) = 3, then the loops iterate 3 * 3 = 9 times.
The space complexity is O(1) because only a constant amount of space is used. 
Variables such as total, i, and j are fixed in memory and do not depend on the input size.
They are not repeatedly created or destroyed like in recursion, meaning no additional stack frames are created (I will explain stack frames later). 
These variables occupy a fixed amount of memory, and their values are simply updated by the code total += arr[i] * arr[j].

class Solution:
    def binarySearch(self, arr, target, left, right):
        if left > right:
            return -1  # 타겟 값을 찾지 못한 경우

        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            return self.binarySearch(arr, target, mid + 1, right)
        else:
            return self.binarySearch(arr, target, left, mid - 1)

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
