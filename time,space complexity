The start time is around 15:24 on September 2, 2024. The end time is about 18:26 on september 2, 2024
The start time is 22:03 on september 2, 2024. The end time is 23:50 on september 2, 2024
I document my undertand of caculating time complexity and space complexity.

class Solution:
    def isPalindrome(self,x:int)->bool:
        if x<0:
            return False
        temp=x
        reverse=0
        while temp>0:
            reverse=reverse*10+temp%10
            temp//=10
        return reverse==x
Although x is an integer, it doesn't mean the loop runs x times. 
As seen in the code, x is divided by 10 in each iteration of the while loop. 
The loop continues until x is no longer divisible by 10. For example, if x = 12321, then x will be divided by 10 repeatedly, 
and the loop will run approximately log(x) times. In this case, x // 10 reduces x each time, so the loop iterates about 5 times (log(12321) ≈ 5).
The space complexity is O(1) because only a constant amount of space is used. 
Variables like x, temp, and reverse occupy a fixed amount of memory, and their values are updated, but the amount of space used does not depend on the input size.

class Solution:
    def isPalindrome(self, x):
        if x < 0 or (x != 0 and x % 10 == 0):
            return False
        reverse = 0
        while x > reverse:
            reverse = reverse * 10 + x % 10
            x //= 10
        return reverse == x or x == reverse // 10
Based on the explanation above, one additional insight is that the solution only iterates over half of the digits of x, 
according to the given code. For instance, if x = 123321, only the last half of the digits, 321, are used in the iteration. 
However, the time complexity is not affected by constant factors such as addition, subtraction, multiplication, or division by constants. 
So it has log(x)/2 ≒ log(x) of time complexity. If we substitute, n=log(123)=log(123321)/2=2.5 ≒ log(123321)=5. That is, You can consider it the same.
The space complexity is same as above Solution. 

def example_algorithm(arr):
    total = 0
    for i in range(len(arr)):
        for j in range(len(arr)):
            total += arr[i] * arr[j]
    return total
Note:x=len(arr)
The time complexity of this solution is O(x^2) because the nested for loops run a total of x^2 iterations. 
For example, if arr = [1, 2, 3] and x = len(arr) = 3, then the loops iterate 3 * 3 = 9 times.
The space complexity is O(1) because only a constant amount of space is used. 
Variables such as total, i, and j are fixed in memory and do not depend on the input size.
They are not repeatedly created or destroyed like in recursion, meaning no additional stack frames are created (I will explain stack frames later). 
These variables occupy a fixed amount of memory, and their values are simply updated by the code total += arr[i] * arr[j].

class Solution:
    def binarySearch(self, arr, target, left, right):
        if left > right:
            return -1  # The case you can't find target value.

        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            return self.binarySearch(arr, target, mid + 1, right)
        else:
            return self.binarySearch(arr, target, left, mid - 1)
Note:x=len(arr)
The time complexity of this solution is O(log2(x)). 

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
It will be used when explaining stack frames.
